# Microcode

## Address bus

Length: 24 bit (3 byte)

```
* 23 OP/I  (CU)
* 22 PC/I  (PC)
* 21 PC/O  (PC)
* 20 +1    (PC)
* 19 AR/I  (RAM)
* 18 R     (RAM)
* 17 W     (RAM)
* 16 DR/I  (RAM)

* 15 DR/O  (RAM)
* 14 BM    (Branch Mode Flag *)
* 13 I/CLR (Clear I/O buffer *)
* 12 1     (ALU)
* 11 OP3   (ALU)
* 10 OP2   (ALU / CCR when BM set)
* 09 OP1   (ALU / CCR when BM set)
* 08 OP0   (ALU / CCR when BM set)

* 07 AX/I  (AX)
* 06 AX/O  (AX)
* 05 BX/I  (BX)
* 04 BX/O  (BX)
* 03 SP/I  (SP)
* 02 SP/O  (SP)
* 01 Z/I   (Z)
* 00 Z/O   (Z)
```

## Instructions

### fetch & decode cycle

```
$00 $280000 001010000000000000000000 AR := PC                 ; fetch
$01 $050000 000001010000000000000000 DR := {AR}
$02 $908000 100100001000000000000000 OP := DR & PC := PC+1
$03 $280000 001010000000000000000000 AR := PC                 ; fetch operands
$04 $150000 000101010000000000000000 DR := {AR} & PC := PC+1
$05 $ffffff 111111111111111111111111                          ; decode
```

### Storage

#### lda #$nn (imm)

```
$06 $008080 000000001000000010000000 AX := DR
$07 $000000 000000000000000000000000                          ; execute
```

#### lda $nn (abs)

```
$08 $088000 000010001000000000000000 AR := DR
$09 $050000 000001010000000000000000 DR := {AR}
$0a $008080 000000001000000010000000 AX := DR
$0b $000000 000000000000000000000000                          ; execute
```

#### ldb #$nn (imm)

```
$0c $008020 000000001000000000100000 BX := DR
$0d $000000 000000000000000000000000                          ; execute
```

#### ldb $nn (abs)

```
$0e $088000 000010001000000000000000 AR := DR
$0f $050000 000001010000000000000000 DR := {AR}
$10 $008020 000000001000000000100000 BX := DR
$11 $000000 000000000000000000000000                          ; execute
```

#### sta $nn (abs)

```
$12 $088000 000010001000000000000000 AR := DR
$13 $010040 000000010000000001000000 DR := AX
$14 $028000 000000101000000000000000 {AR} := DR
$15 $000000 000000000000000000000000                          ; execute
```

#### stb $nn,a (idx)

```
$16 $008002 000000001000000000000010 Z := DR + AX
$17 $080001 000010000000000000000001 AR := Z
$18 $010040 000000010000000001000000 DR := AX
$19 $028000 000000101000000000000000 {AR} := DR
$1a $000000 000000000000000000000000                          ; execute
```

#### stb $nn (abs)

```
$1b $088000 000010001000000000000000 AR := DR
$1c $010010 000000010000000000010000 DR := BX
$1d $028000 000000101000000000000000 {AR} := DR
$1e $000000 000000000000000000000000                          ; execute
```

#### tab

```
$1f $000060 000000000000000001100000 BX := AX
$20 $000000 000000000000000000000000                          ; execute
```

#### tba

```
$21 $000090 000000000000000010010000 AX := BX
$22 $000000 000000000000000000000000                          ; execute
```

### Math

#### adc #$nn (imm)

```
$23 $008002 000000001000000000000010 Z := AX + DR
$24 $000081 000000000000000010000001 AX := Z
$25 $000000 000000000000000000000000                          ; execute
```

#### adc $nn (abs)

```
$26 $088000 000010001000000000000000 AR := DR
$27 $050000 000001010000000000000000 DR := {AR}
$28 $008002 000000001000000000000010 Z := AX + DR
$29 $000081 000000000000000010000001 AX := Z
$2a $000000 000000000000000000000000                          ; execute
```

#### sbc #$nn (imm)

```
$2b $008102 000000001000000100000010 Z := AX - DR
$2c $000081 000000000000000010000001 AX := Z
$2d $000000 000000000000000000000000                          ; execute
```

#### sbc $nn (abs)

```
$2e $088000 000010001000000000000000 AR := DR
$2f $050000 000001010000000000000000 DR := {AR}
$30 $008102 000000001000000100000010 Z := AX - DR
$31 $000081 000000000000000010000001 AX := Z
$32 $000000 000000000000000000000000                          ; execute
```

#### inc

```
$33 $001002 000000000001000000000010 Z := AX + 1
$34 $000081 000000000000000010000001 AX := Z
$35 $000000 000000000000000000000000                          ; execute
```

#### dec

```
$36 $001102 000000000001000100000010 Z := AX - 1
$37 $000081 000000000000000010000001 AX := Z
$38 $000000 000000000000000000000000                          ; execute
```

### Bitwise

#### and #$nn (imm)

```
$39 $008202 000000001000001000000010 Z = AX AND DR
$3a $000081 000000000000000010000001 AX := Z
$3b $000000 000000000000000000000000                          ; execute
```

#### and $nn (abs)

```
$3c $088000 000010001000000000000000 AR := DR
$3d $050000 000001010000000000000000 DR := {AR}
$3e $008202 000000001000001000000010 Z := AX AND DR
$3f $000081 000000000000000010000001 AX := Z
$40 $000000 000000000000000000000000                          ; execute
```

#### ora #$nn (imm)

```
$41 $008302 000000001000001100000010 Z = AX OR DR
$42 $000081 000000000000000010000001 AX := Z
$43 $000000 000000000000000000000000                          ; execute
```

#### ora $nn (abs)

```
$44 $088000 000010001000000000000000 AR := DR
$45 $050000 000001010000000000000000 DR := {AR}
$46 $008302 000000001000001100000010 Z := AX OR DR
$47 $000081 000000000000000010000001 AX := Z
$48 $000000 000000000000000000000000                          ; execute
```

#### eor #$nn (imm)

```
$49 $008402 000000001000010000000010 Z = AX XOR DR
$4a $000081 000000000000000010000001 AX := Z
$4b $000000 000000000000000000000000                          ; execute
```

#### eor $nn (abs)

```
$4c $088000 000010001000000000000000 AR := DR
$4d $050000 000001010000000000000000 DR := {AR}
$4e $008402 000000001000010000000010 Z := AX XOR DR
$4f $000081 000000000000000010000001 AX := Z
$50 $000000 000000000000000000000000                          ; execute
```

#### lsl

```
$51 $000502 000000000000010100000010 Z = AX LSL
$52 $000081 000000000000000010000001 AX := Z
$53 $000000 000000000000000000000000                          ; execute
```

#### lsr

```
$54 $000602 000000000000011000000010 Z = AX LSR
$55 $000081 000000000000000010000001 AX := Z
$56 $000000 000000000000000000000000                          ; execute
```

#### asl

```
$57 $000702 000000000000011100000010 Z = AX ASL
$58 $000081 000000000000000010000001 AX := Z
$59 $000000 000000000000000000000000                          ; execute
```

#### rol

```
$5a $000802 000000000000100000000010 Z = AX ROL
$5b $000081 000000000000000010000001 AX := Z
$5c $000000 000000000000000000000000                          ; execute
```

#### ror

```
$5d $000902 000000000000100100000010 Z = AX ROR
$5e $000081 000000000000000010000001 AX := Z
$5f $000000 000000000000000000000000                          ; execute
```

### Branch

#### bpl #$nn (imm)

```
$60 $400000 010000000000000000000000
$61 $000000 000000000000000000000000                          ; execute
```

#### bmi #$nn (imm)

```
$62 $400100 010000000000000100000000
$63 $000000 000000000000000000000000                          ; execute
```

#### bcc #$nn (imm)

```
$64 $400200 010000000000001000000000
$65 $000000 000000000000000000000000                          ; execute
```

#### bcs #$nn (imm)

```
$66 $400300 010000000000001100000000
$67 $000000 000000000000000000000000                          ; execute
```

#### bne #$nn (imm)

```
$68 $400400 010000000000010000000000
$69 $000000 000000000000000000000000                          ; execute
```

#### beq #$nn (imm)

```
$6a $400500 010000000000010100000000
$6b $000000 000000000000000000000000                          ; execute
```

### Flags

#### sec

```
$6c $400600 010000000000011000000000
$6d $000000 000000000000000000000000                          ; execute
```

#### clc

```
$6e $400700 010000000000011100000000
$6f $000000 000000000000000000000000                          ; execute
```

### Registers

#### cmp #$nn (imm)

```
$70 $008102 000000001000000100000010 Z := AX - DR
$71 $000000 000000000000000000000000                          ; execute
```

#### cmp $nn (abs)

```
$72 $088000 000010001000000000000000 AR := DR
$73 $050000 000001010000000000000000 DR := {AR}
$74 $008102 000000001000000100000010 Z := AX - DR
$75 $000000 000000000000000000000000                          ; execute
```

### Stack

#### pha

```
$76 $080004 000010000000000000000100 [pha] AR := SP
$77 $010040 000000010000000001000000 DR := AX
$78 $028000 000000101000000000000000 {AR} := DR
$79 $000084 000000000000000010000100 AX := SP
$7a $001002 000000000001000000000010 Z := AX + 1
$7b $000009 000000000000000000001001 SP := Z
$7c $008080 000000001000000010000000 AX := DR
$7d $000000 000000000000000000000000                          ; execute
```

#### pop

```
$7e $000084 000000000000000010000100 [pop] AX := SP
$7f $001102 000000000001000100000010 Z = AX - 1
$80 $080009 000010000000000000001001 SP := Z & AR := Z
$81 $050000 000001010000000000000000 DR := {AR}
$82 $008080 000000001000000010000000 AX := DR
$83 $000000 000000000000000000000000                          ; execute
```

### Jumps

#### jmp #$nn (imm)

```
$84 $400000 010000000000000000000000 PC := DR
$85 $000000 000000000000000000000000                          ; execute
```

#### jmp $nn (abs)

```
$86 $088000 000010001000000000000000 AR := DR
$87 $050000 000001010000000000000000 DR := {AR}
$88 $400000 010000000000000000000000 PC := DR
$89 $000000 000000000000000000000000                          ; execute
```

#### jsr #$nn (imm)

```
$8a $008080 000000001000000010000000 AX := DR                 ; keep operand
$8b $080004 000010000000000000000100 AR := SP                 ; save sp
$8c $210000 001000010000000000000000 DR := PC
$8d $028000 000000101000000000000000 {AR} := DR
$8e $010040 000000010000000001000000 DR := AX                 ; change pc
$8f $400000 010000000000000000000000 PC := DR
$90 $000084 000000000000000010000100 AX := SP                 ; increase sp
$91 $001002 000000000001000000000010 Z := AX + 1
$92 $000009 000000000000000000001001 SP := Z
$93 $000000 000000000000000000000000                          ; execute
```

#### jsr $nn (abs)

```
$94 $088000 000010001000000000000000 AR := DR                 ; read jump address
$95 $050000 000001010000000000000000 DR := {AR}
$96 $200080 001000000000000010000000 AX := PC                 ; store pc
$97 $400000 010000000000000000000000 PC := DR                 ; jump to address
$98 $010040 000000010000000001000000 DR := AX
$99 $080084 000010000000000010000100 AR := SP & AX := SP
$9a $001002 000000000001000000000010 Z := AX + 1
$9b $000009 000000000000000000001001 SP := Z
$9c $000000 000000000000000000000000                          ; execute
```

#### rts

```
$9d $000084 000000000000000010000100 AX := SP                 ; decrease sp
$9e $001102 000000000001000100000010 Z := AX - 1
$9f $080009 000010000000000000001001 SP := Z & AR := Z        ; get address from stack
$a0 $050000 000001010000000000000000 DR := {AR}
$a1 $400000 010000000000000000000000 PC := DR                 ; jump to address
$a2 $000000 000000000000000000000000                          ; execute
```

### Special

#### cib

```
$a3 $002000 000000000010000000000000                          ; clear input buffer
$a4 $000000 000000000000000000000000                          ; execute
```
